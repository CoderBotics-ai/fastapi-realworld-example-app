from typing import List, Optional, Sequence, Union

from asyncpg import Connection, Record
from pypika import Query

from app.db.errors import EntityDoesNotExist
from app.db.queries.queries import queries
from app.db.repositories.base import BaseRepository
from app.db.repositories.profiles import ProfilesRepository
from app.db.repositories.tags import TagsRepository
from app.models.domain.articles import Article
from app.models.domain.users import User
from bson.objectid import ObjectId
from pymongo import MongoClient
from pymongo import MongoClient, ASCENDING
from pymongo.results import InsertOneResult, UpdateResult, DeleteResult
from typing import List
from pymongo.results import UpdateResult
from app.db.queries.tables import (
    Parameter,
    articles,
    articles_to_tags,
    favorites,
    tags as tags_table,
    users,
)

AUTHOR_USERNAME_ALIAS = "author_username"
SLUG_ALIAS = "slug"

CAMEL_OR_SNAKE_CASE_TO_WORDS = r"^[a-z\d_\-]+|[A-Z\d_\-][^A-Z\d_\-]*"
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































class ArticlesRepository(BaseRepository):

    def __init__(self, client: MongoClient, db_name: str) -> None:
        self._db = client[db_name]
        self._profiles_repo = ProfilesRepository(client, db_name)
        self._tags_repo = TagsRepository(client, db_name)


    async def create_article(  # noqa: WPS211
        self,
        *,
        slug: str,
        title: str,
        description: str,
        body: str,
        author: User,
        tags: Optional[Sequence[str]] = None,
    ) -> Article:
        author_id = author.username  # Assuming username is unique and can be used as ObjectId
        article_data = {
            "slug": slug,
            "title": title,
            "description": description,
            "body": body,
            "author_id": author_id,
            "tags": tags if tags else [],
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
        }
        result = await self.articles_collection.insert_one(article_data)
        article_id = result.inserted_id

        if tags:
            for tag in tags:
                tag_data = await self.tags_collection.find_one({"tag": tag})
                if not tag_data:
                    await self.tags_collection.insert_one({"tag": tag, "articles": [article_id]})
                else:
                    await self.tags_collection.update_one(
                        {"_id": tag_data["_id"]},
                        {"$addToSet": {"articles": article_id}}
                    )

        author_data = await self.users_collection.find_one({"username": author_id})
        if author_data:
            await self.users_collection.update_one(
                {"_id": author_data["_id"]},
                {"$addToSet": {"articles": article_id}}
            )

        return await self._get_article_from_db_record(
            article_id=article_id,
            slug=slug,
            author_username=author_id,
            requested_user=author,
        )


    async def update_article(  # noqa: WPS211
        self,
        *,
        article: Article,
        slug: Optional[str] = None,
        title: Optional[str] = None,
        body: Optional[str] = None,
        description: Optional[str] = None,
    ) -> Article:
        updated_article = article.copy(deep=True)
        updated_article.slug = slug or updated_article.slug
        updated_article.title = title or article.title
        updated_article.body = body or article.body
        updated_article.description = description or article.description

        # Update the article in the MongoDB collection
        update_data = {
            "$set": {
                "slug": updated_article.slug,
                "title": updated_article.title,
                "body": updated_article.body,
                "description": updated_article.description,
                "updated_at": datetime.utcnow()  # Assuming you have a way to get the current UTC time
            }
        }
        self.articles_collection.update_one(
            {"slug": article.slug, "author_id": article.author.id},  # Filter criteria
            update_data,
            upsert=False
        )

        return updated_article


    async def delete_article(self, *, article: Article) -> None:
        # Assuming the article has a 'slug' attribute
        result = self.collection.delete_one({'slug': article.slug, 'author_id': article.author.id})
        if result.deleted_count == 0:
            raise EntityDoesNotExist(f"Article with slug {article.slug} does not exist.")


    async def filter_articles(  # noqa: WPS211
        self,
        *,
        tag: Optional[str] = None,
        author: Optional[str] = None,
        favorited: Optional[str] = None,
        limit: int = 20,
        offset: int = 0,
        requested_user: Optional[User] = None,
    ) -> List[Article]:
        query = {}

        if tag:
            tag_obj = await self.tags_collection.find_one({'tag': tag})
            if tag_obj:
                query['_id'] = {'$in': tag_obj['articles']}

        if author:
            author_obj = await self.users_collection.find_one({'username': author})
            if author_obj:
                query['author_id'] = author_obj['_id']

        if favorited:
            favorited_obj = await self.users_collection.find_one({'username': favorited})
            if favorited_obj:
                query['_id'] = {'$in': favorited_obj['favorites']}

        cursor = self.articles_collection.find(query).skip(offset).limit(limit)
        articles = await cursor.to_list(length=None)

        for article in articles:
            author_obj = await self.users_collection.find_one({'_id': article['author_id']})
            if author_obj:
                article['author_username'] = author_obj['username']

        return articles


    async def get_articles_for_user_feed(
        self,
        *,
        user: User,
        limit: int = 20,
        offset: int = 0,
    ) -> List[Article]:
        # Assuming that the user's followers are stored in the 'followers' field of the user document
        # and that the articles are sorted by 'created_at' in descending order
        pipeline = [
            {"$match": {"author_id": {"$in": user.followers}}},
            {"$sort": {"created_at": -1}},
            {"$skip": offset},
            {"$limit": limit},
            {"$lookup": {
                "from": "users",
                "localField": "author_id",
                "foreignField": "_id",
                "as": "author"
            }},
            {"$unwind": "$author"},
            {"$project": {
                "slug": 1,
                "title": 1,
                "description": 1,
                "body": 1,
                "author_username": "$author.username",
                "created_at": 1,
                "updated_at": 1
            }}
        ]
        articles_cursor = self.articles_collection.aggregate(pipeline)
        return [
            await self._get_article_from_db_record(
                article_row=article_row,
                slug=article_row['slug'],
                author_username=article_row['author_username'],
                requested_user=user,
            )
            for article_row in await articles_cursor.to_list(length=None)
        ]

    async def get_article_by_slug(
        self,
        *,
        slug: str,
        requested_user: Optional[User] = None,
    ) -> Article:
        article_row = await queries.get_article_by_slug(self.connection, slug=slug)
        if article_row:
            return await self._get_article_from_db_record(
                article_row=article_row,
                slug=article_row[SLUG_ALIAS],
                author_username=article_row[AUTHOR_USERNAME_ALIAS],
                requested_user=requested_user,
            )

        raise EntityDoesNotExist("article with slug {0} does not exist".format(slug))


    async def get_tags_for_article_by_slug(self, *, slug: str) -> List[str]:
        article = self.articles_collection.find_one({"slug": slug})
        if article is None:
            raise EntityDoesNotExist("Article not found")
        return article.get("tags", [])


    async def get_favorites_count_for_article_by_slug(self, *, slug: str) -> int:
        article = self.articles_collection.find_one({"slug": slug})
        if article is None:
            raise EntityDoesNotExist("Article does not exist")
        return len(article["favorited_by"])


    async def is_article_favorited_by_user(self, *, slug: str, user: User) -> bool:
        user_id = self._get_user_id_by_username(user.username)
        if not user_id:
            return False

        article = self.articles_collection.find_one({"slug": slug})
        if not article:
            return False

        return user_id in article.get("favorited_by", [])


    async def add_article_into_favorites(self, *, article: Article, user: User) -> None:
        user_id = ObjectId(user.username)  # Assuming username is the unique identifier for users
        article_id = ObjectId(article.slug)  # Assuming slug is the unique identifier for articles

        # Add the article ID to the user's favorites
        result: UpdateResult = self.users_collection.update_one(
            {"_id": user_id},
            {"$addToSet": {"favorites": article_id}}
        )

        if result.modified_count == 0:
            raise EntityDoesNotExist(f"User with ID {user_id} does not exist.")

        # Add the user ID to the article's favorited_by
        result = self.articles_collection.update_one(
            {"_id": article_id},
            {"$addToSet": {"favorited_by": user_id}}
        )

        if result.modified_count == 0:
            raise EntityDoesNotExist(f"Article with ID {article_id} does not exist.")

    def _get_user_id_by_username(self, username: str) -> Optional[ObjectId]:
        user = self.users_collection.find_one({"username": username})
        return user.get("_id") if user else None


    async def remove_article_from_favorites(
        self,
        *,
        article: Article,
        user: User,
    ) -> None:
        user_collection = self.db['users']
        article_collection = self.db['articles']

        # Remove the article from the user's favorites
        user_filter = {'username': user.username}
        user_update = {'$pull': {'favorites': article.id}}
        user_result: UpdateResult = user_collection.update_one(user_filter, user_update)

        if user_result.modified_count == 0:
            raise EntityDoesNotExist(f"User with username {user.username} not found")

        # Remove the user from the article's favorited_by
        article_filter = {'slug': article.slug}
        article_update = {'$pull': {'favorited_by': user.id}}
        article_result: UpdateResult = article_collection.update_one(article_filter, article_update)

        if article_result.modified_count == 0:
            raise EntityDoesNotExist(f"Article with slug {article.slug} not found")


    async def _get_article_from_db_record(
        self,
        *,
        article_doc: dict,
        slug: str,
        author_username: str,
        requested_user: Optional[User],
    ) -> Article:
        return Article(
            id_=article_doc["_id"],
            slug=slug,
            title=article_doc["title"],
            description=article_doc["description"],
            body=article_doc["body"],
            author=await self._profiles_repo.get_profile_by_username(
                username=author_username,
                requested_user=requested_user,
            ),
            tags=await self.get_tags_for_article_by_slug(slug=slug),
            favorites_count=await self.get_favorites_count_for_article_by_slug(
                slug=slug,
            ),
            favorited=await self.is_article_favorited_by_user(
                slug=slug,
                user=requested_user,
            )
            if requested_user
            else False,
            created_at=article_doc["created_at"],
            updated_at=article_doc["updated_at"],
        )

    async def _link_article_with_tags(self, *, slug: str, tags: Sequence[str]) -> None:
        await queries.add_tags_to_article(
            self.connection,
            [{SLUG_ALIAS: slug, "tag": tag} for tag in tags],
        )
