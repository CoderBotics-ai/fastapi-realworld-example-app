from typing import List, Optional, Sequence, Union

from asyncpg import Connection, Record
from pypika import Query

from app.db.errors import EntityDoesNotExist
from app.db.queries.queries import queries
from app.db.repositories.base import BaseRepository
from app.db.repositories.profiles import ProfilesRepository
from app.db.repositories.tags import TagsRepository
from app.models.domain.articles import Article
from app.models.domain.users import User
from app.db.queries.tables import (
    Parameter,
    articles,
    articles_to_tags,
    favorites,
    tags as tags_table,
    users,
)

AUTHOR_USERNAME_ALIAS = "author_username"
SLUG_ALIAS = "slug"

CAMEL_OR_SNAKE_CASE_TO_WORDS = r"^[a-z\d_\-]+|[A-Z\d_\-][^A-Z\d_\-]*"
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































class ArticlesRepository(BaseRepository):
    def __init__(self, conn: Connection) -> None:
        super().__init__(conn)
        self._profiles_repo = ProfilesRepository(conn)
        self._tags_repo = TagsRepository(conn)


    async def create_article(
        self,
        *,
        slug: str,
        title: str,
        description: str,
        body: str,
        author: User,
        tags: Optional[Sequence[str]] = None,
    ) -> Article:
        article_document = {
            "slug": slug,
            "title": title,
            "description": description,
            "body": body,
            "author_id": author.id,
            "created_at": datetime.datetime.utcnow(),
            "updated_at": datetime.datetime.utcnow(),
            "tags": tags if tags else [],
            "favorited_by": [],
            "comments": []
        }

        result = await self.db["articles"].insert_one(article_document)
        article_document["_id"] = result.inserted_id

        if tags:
            await self._tags_repo.create_tags_that_dont_exist(tags=tags)
            await self._link_article_with_tags(article_id=result.inserted_id, tags=tags)

        return await self._get_article_from_db_record(
            article_document=article_document,
            slug=slug,
            author_username=author.username,
            requested_user=author,
        )

    async def update_article(
        self,
        *,
        article: Article,
        slug: Optional[str] = None,
        title: Optional[str] = None,
        body: Optional[str] = None,
        description: Optional[str] = None,
    ) -> Article:
        updated_article = article.copy(deep=True)
        updated_article.slug = slug or updated_article.slug
        updated_article.title = title or article.title
        updated_article.body = body or article.body
        updated_article.description = description or article.description

        update_data = {
            "slug": updated_article.slug,
            "title": updated_article.title,
            "body": updated_article.body,
            "description": updated_article.description,
            "updated_at": datetime.datetime.utcnow()
        }

        await self.connection["articles"].update_one(
            {"slug": article.slug, "author_id": article.author.id},
            {"$set": update_data}
        )

        return updated_article

    async def delete_article(self, *, article: Article) -> None:
        result = await self.connection["articles"].delete_one({"slug": article.slug, "author_id": article.author.id})
        if result.deleted_count == 0:
            raise EntityDoesNotExist("article with the given slug and author does not exist")

    async def filter_articles(
        self,
        *,
        tag: Optional[str] = None,
        author: Optional[str] = None,
        favorited: Optional[str] = None,
        limit: int = 20,
        offset: int = 0,
        requested_user: Optional[User] = None,
    ) -> List[Article]:
        query = {"$and": []}

        if tag:
            query["$and"].append({"tags": tag})

        if author:
            user = await self.db.users.find_one({"username": author}, {"_id": 1})
            if user:
                query["$and"].append({"author_id": user["_id"]})

        if favorited:
            favorited_user = await self.db.users.find_one({"username": favorited}, {"_id": 1})
            if favorited_user:
                query["$and"].append({"favorited_by": favorited_user["_id"]})

        articles_cursor = self.db.articles.find(
            query,
            projection={
                "slug": 1,
                "title": 1,
                "description": 1,
                "body": 1,
                "created_at": 1,
                "updated_at": 1,
                "author_id": 1
            }
        ).skip(offset).limit(limit)

        articles = []
        async for article_doc in articles_cursor:
            author_user = await self.db.users.find_one({"_id": article_doc["author_id"]})
            articles.append(
                await self._get_article_from_db_record(
                    article_row=article_doc,
                    slug=article_doc["slug"],
                    author_username=author_user["username"] if author_user else None,
                    requested_user=requested_user,
                )
            )

        return articles

    async def get_articles_for_user_feed(
        self,
        *,
        user: User,
        limit: int = 20,
        offset: int = 0,
    ) -> List[Article]:
        articles_collection = self.db["articles"]
        users_collection = self.db["users"]

        # Find the user's followings
        user_doc = await users_collection.find_one({"username": user.username})
        if not user_doc:
            raise EntityDoesNotExist("user not found")

        followings = user_doc.get("followings", [])

        # Fetch articles written by followings
        articles_cursor = articles_collection.find(
            {"author_id": {"$in": followings}},
            limit=limit,
            skip=offset,
            sort=[("created_at", -1)]
        )
        articles_rows = await articles_cursor.to_list(length=limit)

        # Convert documents to Article domain model instances
        return [
            await self._get_article_from_db_record(
                article_row=article_row,
                slug=article_row["slug"],
                author_username=(await users_collection.find_one({"_id": article_row["author_id"]})).get("username"),
                requested_user=user,
            )
            for article_row in articles_rows
        ]


    async def get_article_by_slug(
        self,
        *,
        slug: str,
        requested_user: Optional[User] = None,
    ) -> Article:
        article_document = await self.connection["articles"].find_one({"slug": slug})
        if article_document:
            return await self._get_article_from_db_record(
                article_row=article_document,
                slug=article_document["slug"],
                author_username=article_document["author_id"],  # Assuming author_id maps to username in user collection
                requested_user=requested_user,
            )

        raise EntityDoesNotExist("article with slug {0} does not exist".format(slug))


    async def get_tags_for_article_by_slug(self, *, slug: str) -> List[str]:
        article_document = await self.db.articles.find_one({"slug": slug}, {"tags": 1})
        if not article_document:
            raise EntityDoesNotExist("article with slug {0} does not exist".format(slug))
        return article_document["tags"]


    async def get_favorites_count_for_article_by_slug(self, *, slug: str) -> int:
        article = await self.db.articles.find_one({"slug": slug}, {"favorited_by": 1})
        if not article:
            raise EntityDoesNotExist("article with slug {slug} does not exist")
        return len(article["favorited_by"])


    async def is_article_favorited_by_user(self, *, slug: str, user: User) -> bool:
        article_collection = self.db["articles"]
        user_collection = self.db["users"]
        
        user_doc = await user_collection.find_one({"username": user.username})
        if not user_doc:
            raise EntityDoesNotExist("user with username does not exist")
        
        article_doc = await article_collection.find_one({"slug": slug})
        if not article_doc:
            raise EntityDoesNotExist("article with slug does not exist")
        
        return article_doc["_id"] in user_doc["favorites"]

    async def add_article_into_favorites(self, *, article: Article, user: User) -> None:
        user_collection = self.db["users"]
        article_collection = self.db["articles"]

        user_id = await user_collection.find_one({"username": user.username}, {"_id": 1})
        article_id = await article_collection.find_one({"slug": article.slug}, {"_id": 1})

        if not user_id or not article_id:
            raise EntityDoesNotExist("User or Article does not exist.")

        await user_collection.update_one(
            {"_id": user_id["_id"]},
            {"$addToSet": {"favorites": article_id["_id"]}}
        )
        await article_collection.update_one(
            {"_id": article_id["_id"]},
            {"$addToSet": {"favorited_by": user_id["_id"]}}
        )

    async def remove_article_from_favorites(
        self,
        *,
        article: Article,
        user: User,
    ) -> None:
        users_collection = self.db.get_collection("users")
        articles_collection = self.db.get_collection("articles")

        # Find the user and article by their unique identifiers
        user_id = await users_collection.find_one({"username": user.username}, {"_id": 1})
        article_id = await articles_collection.find_one({"slug": article.slug}, {"_id": 1})

        if not user_id or not article_id:
            raise EntityDoesNotExist("User or article does not exist.")

        # Update the user's favorites and the article's favorited_by fields
        await users_collection.update_one(
            {"_id": user_id["_id"]},
            {"$pull": {"favorites": article_id["_id"]}}
        )
        await articles_collection.update_one(
            {"_id": article_id["_id"]},
            {"$pull": {"favorited_by": user_id["_id"]}}
        )

    async def _get_article_from_db_record(
        self,
        *,
        article_row: Record,
        slug: str,
        author_username: str,
        requested_user: Optional[User],
    ) -> Article:
        return Article(
            id_=article_row["id"],
            slug=slug,
            title=article_row["title"],
            description=article_row["description"],
            body=article_row["body"],
            author=await self._profiles_repo.get_profile_by_username(
                username=author_username,
                requested_user=requested_user,
            ),
            tags=await self.get_tags_for_article_by_slug(slug=slug),
            favorites_count=await self.get_favorites_count_for_article_by_slug(
                slug=slug,
            ),
            favorited=await self.is_article_favorited_by_user(
                slug=slug,
                user=requested_user,
            )
            if requested_user
            else False,
            created_at=article_row["created_at"],
            updated_at=article_row["updated_at"],
        )

    async def _link_article_with_tags(self, *, slug: str, tags: Sequence[str]) -> None:
        await queries.add_tags_to_article(
            self.connection,
            [{SLUG_ALIAS: slug, "tag": tag} for tag in tags],
        )
